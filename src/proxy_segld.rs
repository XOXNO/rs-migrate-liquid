// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct LiquidStakingProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for LiquidStakingProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = LiquidStakingProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        LiquidStakingProxyMethods { wrapped_tx: tx }
    }
}

pub struct LiquidStakingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> LiquidStakingProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the contract. 
    ///  
    /// # Arguments 
    ///  
    /// - `unbond_period` - the unbond period in epochs. Devnet has an unbond period of 1 epoch while Mainnet has an 
    ///   unbond period of 10 epochs 
    /// - `opt_admin` - the optional admin address 
    ///  
    pub fn init<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        unbond_period: Arg0,
        opt_admin: Arg1,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&unbond_period)
            .argument(&opt_admin)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LiquidStakingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LiquidStakingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Returns the current admin address. 
    ///  
    /// # Returns: 
    ///  
    /// - The current admin address. 
    ///  
    pub fn get_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmin")
            .original_result()
    }

    /// Returns the current pending admin address, if there is one. 
    ///  
    /// # Returns: 
    ///  
    /// - An `Option` containing the pending admin address if there is one, or `None` if there is not. 
    ///  
    pub fn get_pending_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingAdmin")
            .original_result()
    }

    /// Sets the pending admin address to the given address. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_pending_admin` - The new pending admin address. 
    ///  
    pub fn set_pending_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pending_admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingAdmin")
            .argument(&pending_admin)
            .original_result()
    }

    /// Attempts to accept the pending admin, which must be set first using the `set_pending_admin` endpoint. 
    pub fn accept_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptAdmin")
            .original_result()
    }

    pub fn is_liquid_staking(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isLiquidStaking")
            .original_result()
    }

    pub fn is_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isActive")
            .original_result()
    }

    /// Returns the liquid staking token identifier 
    ///  
    pub fn get_ls_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLsTokenId")
            .original_result()
    }

    /// Computes the current exchange rate in WAD between EGLD and sEGLD 
    ///  
    pub fn get_exchange_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getExchangeRate")
            .original_result()
    }

    /// Allows users to stake EGLD in exchange for sEGLD. The Delegation smart contract is selected based on the current 
    /// configuration of the delegation algorithm. However, this endpoint does not automatically perform the delegation. 
    /// Instead, anyone can perform the delegation at any given point in time using the `delegatePendingAmount` public 
    /// endpoint. 
    ///  
    /// # Notes 
    ///  
    /// - There is a minimum amount of 1 EGLD required for delegations. 
    /// - If the caller is whitelisted, they may bypass the delegation algorithm. 
    /// - The amount of sEGLD minted depends on the current exchange rate between EGLD and sEGLD. 
    ///  
    pub fn delegate(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("delegate")
            .original_result()
    }

    /// Initiates the delegation of the pending amount to the specified Delegation smart contract. This endpoint 
    /// performs an asynchronous call to delegate the pending amount. It is capable of handling multiple calls, and the 
    /// execution order of their callbacks does not need to match the order of the original calls. 
    ///  
    /// # Arguments 
    ///  
    /// - `delegation_contract`: The Delegation smart contract to delegate to. 
    /// - `opt_egld_amount`: The optional EGLD amount to delegate. If not specified, it will delegate the entire pending 
    ///   amount. 
    ///  
    /// # Notes 
    ///  
    /// - This endpoint can be called by anyone. 
    /// - The EGLD amount can be smaller than the pending amount if it exceeds the capacity of the Delegation smart 
    ///   contract. 
    /// - If the delegation fails, the pending amount will be reverted, and the Delegation smart contract will be marked 
    ///   as outdated. A new attempt with a smaller EGLD amount can be made later. 
    /// - If there is pending amount that cannot be delegated, the admin can penalize the Delegation smart contract and 
    ///   delegate that amount to a different Delegation smart contract. 
    ///  
    pub fn delegate_pending_amount<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        delegation_contract: Arg0,
        opt_egld_amount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("delegatePendingAmount")
            .argument(&delegation_contract)
            .argument(&opt_egld_amount)
            .original_result()
    }

    /// Issues the liquid staking token, namely the sEGLD token. 
    ///  
    /// # Arguments 
    ///  
    /// - `name` - the token name 
    /// - `ticker` - the token ticker or symbol 
    /// - `decimals` - the token decimals 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn register_ls_token<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<usize>,
    >(
        self,
        name: Arg0,
        ticker: Arg1,
        decimals: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("registerLsToken")
            .argument(&name)
            .argument(&ticker)
            .argument(&decimals)
            .original_result()
    }

    /// Gives Mint and Burn roles for sEGLD to this contract. 
    ///  
    pub fn set_ls_token_roles(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLsTokenRoles")
            .original_result()
    }

    /// Issues the Undelegate Nft, the token minted at undelegations as a receipt. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn register_undelegate_token<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        name: Arg0,
        ticker: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("registerUndelegateToken")
            .argument(&name)
            .argument(&ticker)
            .original_result()
    }

    /// Gives Mint and Burn roles for the Undelegate Nft to this contract. 
    ///  
    pub fn set_undelegate_token_roles(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setUndelegateTokenRoles")
            .original_result()
    }

    /// Sets the Data Manager entitled to change the data associated to each Delegation smart contract. 
    ///  
    /// # Arguments 
    ///  
    /// - `new_data_manager` - the address of the new Data Manager 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn set_data_manager<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        new_data_manager: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setDataManager")
            .argument(&new_data_manager)
            .original_result()
    }

    /// Activates the Liquid Staking Module state. The activation can only occur iff: 
    ///  
    /// - the total fee has been set 
    /// - the Liquid Staking token has been issued 
    /// - the undelegate NFT has been issued 
    /// - the delegation score model has been defined 
    /// - the data manager has been set 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn set_state_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setStateActive")
            .original_result()
    }

    /// Deactivates the Liquid Staking Module state. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn set_state_inactive(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setStateInactive")
            .original_result()
    }

    /// Whitelists a Staking Provider Delegation smart contract. From this point onwards, this smart contract will be 
    /// eligible as a Delegation smart contract based on the state of the delegation algorithm. This method can also be 
    /// used to whitelist a previously blacklisted Delegation smart contract. 
    ///  
    /// # Arguments 
    ///  
    /// - `contract` - the Delegation smart contract address 
    /// - `admin` - the address entitled to update this Delegation smart contract data 
    /// - `total_value_locked` - the liquidity locked at the Delegation smart contract 
    /// - `nr_nodes` - the number of validator nodes 
    /// - `apr` - the current APR for the validator 
    /// - `service_fee` - the service fee being charged by the validator 
    /// - `opt_cap` - the maximum amount that can be locked at the Delegation smart contract (uncapped if `None`) 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - it will compute a delegation score based on the current state of the delegation algorithm 
    ///  
    pub fn whitelist_delegation_contract<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        delegation_contract: Arg0,
        total_value_locked: Arg1,
        nr_nodes: Arg2,
        apr: Arg3,
        service_fee: Arg4,
        opt_cap: Arg5,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("whitelistDelegationContract")
            .argument(&delegation_contract)
            .argument(&total_value_locked)
            .argument(&nr_nodes)
            .argument(&apr)
            .argument(&service_fee)
            .argument(&opt_cap)
            .original_result()
    }

    /// Blacklists a Delegation smart contract. From this point onwards, this smart contract will not be eligible as a 
    /// Delegation smart contract through the delegation algorithm. 
    ///  
    /// # Arguments 
    ///  
    /// - `delegation_contract` - the Delegation smart contract address 
    ///  
    pub fn blacklist_delegation_contract<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        delegation_contract: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("blacklistDelegationContract")
            .argument(&delegation_contract)
            .original_result()
    }

    /// Updates the data for a given Staking Provider Delegation smart contract. 
    ///  
    /// # Arguments 
    ///  
    /// - `contract` - the Delegation smart contract address 
    /// - `admin` - the address entitled to update this Delegation smart contract data 
    /// - `total_value_locked` - the liquidity locked at the Delegation smart contract 
    /// - `nr_nodes` - the number of validator nodes 
    /// - `apr` - the current APR for the validator 
    /// - `service_fee` - the service fee being charged by the validator 
    /// - `opt_cap` - the maximum amount that can be locked at the Delegation smart contract (uncapped if `None`) 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin set for the Delegation smart contract data 
    /// - will revert if the contract has been blacklisted 
    /// - it will compute a delegation score based on the current state of the delegation algorithm 
    ///  
    pub fn change_delegation_contract_params<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        delegation_contract: Arg0,
        total_value_locked: Arg1,
        nr_nodes: Arg2,
        apr: Arg3,
        service_fee: Arg4,
        opt_cap: Arg5,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("changeDelegationContractParams")
            .argument(&delegation_contract)
            .argument(&total_value_locked)
            .argument(&nr_nodes)
            .argument(&apr)
            .argument(&service_fee)
            .argument(&opt_cap)
            .original_result()
    }

    /// Withdraws a given amount of EGLD from the protocol reserves to an optionally given account. 
    ///  
    /// # Arguments 
    ///  
    /// - `egld_amount` - the amount of EGLD to withdraw 
    /// - `opt_to` - an optional address to send the EGLD to 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - the EGLD amount is directed to the admin account if none is provided 
    ///  
    pub fn withdraw_reserve<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        egld_amount: Arg0,
        opt_to: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdrawReserve")
            .argument(&egld_amount)
            .argument(&opt_to)
            .original_result()
    }

    /// Sets the total fee, which represents the final fee end users see discounted from their rewards based on the 
    /// service fee charged by each Staking Provider and by this Liquid Staking protocol. For example, if a Staking 
    /// Provider has a service fee of 7% and the total fee is set to 17%, the Liquid Staking Protocol will charge a 10% 
    /// fee from the total rewards. 
    ///  
    /// # Arguments 
    ///  
    /// - `fee` - the total fee in basis points 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn set_total_fee<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        fee: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setTotalFee")
            .argument(&fee)
            .original_result()
    }

    /// Sets the Delegation Score Model parameters used for the computation of the delegation score for each Staking 
    /// Provider Delegation smart contract. Higher scores imply better chances of being selected at delegations as well 
    /// as lower chances of being selected for undelegations. 
    ///  
    /// # Arguments 
    ///  
    /// - `method` - the score can be based only on Total Value Locked, APR or a weighted mix of both parameters 
    /// - `min_tvl` - Delegation smart contracts with lower TVLs than this parameters share the same TVL score 
    /// - `max_tvl` - Delegation smart contracts with higher TVLs than this parameters share the same TVL score 
    /// - `min_apr` - Delegation smart contracts with lower APRs than this parameters share the same APR score (in bps) 
    /// - `max_apr` - Delegation smart contracts with higher APRs than this parameters share the same APR score (in bps) 
    /// - `opt_omega` - should be given only for a Mixed delegation score method and defines the weight for both TVL and 
    ///   APR scores 
    /// - `sort` - if true, the list of Delegation smart contracts will be sorted based on the new delegation score 
    ///   model parameters. If false, the sorting is left to `changeDelegationContractParams`. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn set_delegation_score_model_params<
        Arg0: ProxyArg<DelegationScoreMethod>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<bool>,
        Arg6: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        method: Arg0,
        min_tvl: Arg1,
        max_tvl: Arg2,
        min_apr: Arg3,
        max_apr: Arg4,
        sort: Arg5,
        opt_omega: Arg6,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setDelegationScoreModelParams")
            .argument(&method)
            .argument(&min_tvl)
            .argument(&max_tvl)
            .argument(&min_apr)
            .argument(&max_apr)
            .argument(&sort)
            .argument(&opt_omega)
            .original_result()
    }

    /// Sets the Delegation Sampling Model parameters used for the random selection between candidates on a computed 
    /// list of Staking Providers Delegation smart contracts. 
    ///  
    /// # Arguments 
    ///  
    /// - `tolerance` - the tolerance (as percentage and as bps) used to build the list of candidates 
    /// - `max_service_fee` - from this point onwards, staking providers do not receive delegations in bps 
    /// - `premium` - the difference between the delegation weight at service_fee = 0 and the delegation weight at 
    ///   service_fee = max_service_fee in bps 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn set_delegation_sampling_model_params<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        tolerance: Arg0,
        max_service_fee: Arg1,
        premium: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setDelegationSamplingModelParams")
            .argument(&tolerance)
            .argument(&max_service_fee)
            .argument(&premium)
            .original_result()
    }

    /// Clears the Delegation Sampling Model, i.e. removes the sampling from delegation and undelegation candidates. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn clear_delegation_sampling_model(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("clearDelegationSamplingModel")
            .original_result()
    }

    /// A public endpoint that allows to start bypassing the undelegation algorithm in order to undelegate and, 
    /// consequently, withdraw EGLD from the protocol. 
    ///  
    /// # Notes 
    ///  
    /// - can be called by anyone after `NO_UNDELEGATIONS_EPOCHS` have passed since the last undelegation 
    ///  
    pub fn deactivate_undelegation_algorithm(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("deactivateUndelegationAlgorithm")
            .original_result()
    }

    /// An admin endpoint that reactivates the undelegation algorithm. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - can only be reactivated after `NO_UNDELEGATIONS_EPOCHS + COOLDOWN_REACTIVATE_UNDELEGATION_ALGORITHM` have 
    ///   elapsed since the last undelegation 
    ///  
    pub fn reactivate_undelegation_algorithm(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("reactivateUndelegationAlgorithm")
            .original_result()
    }

    /// Adds an entry to the migration whitelist. This whitelist allows users to bypass the Delegation Algorithm for 
    /// delegates. 
    ///  
    /// # Arguments 
    ///  
    /// - `user` - the user that wil be entitled to bypass the delegation algorithm 
    /// - `delegation_contract` - the Delegation smart contract 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn add_to_migration_whitelist<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user: Arg0,
        delegation_contract: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addToMigrationWhitelist")
            .argument(&user)
            .argument(&delegation_contract)
            .original_result()
    }

    /// Removes an entry from the migration whitelist. 
    ///  
    /// # Arguments 
    ///  
    /// - `user` - the user that is currently entitled to bypass the delegation algorithm 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn remove_from_migration_whitelist<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeFromMigrationWhitelist")
            .argument(&user)
            .original_result()
    }

    /// Removes the caller from the migration whitelist. 
    ///  
    pub fn remove_me_from_migration_whitelist(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeMeFromMigrationWhitelist")
            .original_result()
    }

    /// Allows anyone to claim rewards from a given Delegation smart contract. 
    ///  
    /// # Arguments 
    ///  
    /// - `delegation_contract` - the Delegation smart contract address 
    ///  
    pub fn claim_rewards_from<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        delegation_contract: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRewardsFrom")
            .argument(&delegation_contract)
            .original_result()
    }

    /// Allows anyone to delegate EGLD rewards balance to a staking provider based on the current configuration of the 
    /// delegation algorithm. If the delegation is successful, the callback updates the storage. Otherwise, it sets the 
    /// Delegation smart contract data as outdated. Notice that the smart contract data will be outdated until it is updated. 
    ///  
    /// # Arguments 
    ///  
    /// - `opt_egld_amount` - an optional amount of EGLD from the rewards balance to delegate 
    ///  
    pub fn delegate_rewards<
        Arg0: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        opt_egld_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("delegateRewards")
            .argument(&opt_egld_amount)
            .original_result()
    }

    /// The current state of the Liquid Staking module 
    pub fn state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, State> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getState")
            .original_result()
    }

    /// The current outstanding supply of sEGLD or the current amount of total shares 
    pub fn ls_token_supply(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLsSupply")
            .original_result()
    }

    /// The NFT given in exchange for sEGLD at unDelegations 
    pub fn undelegate_token(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUndelegateTokenId")
            .original_result()
    }

    /// The Undelegate NFT name 
    pub fn undelegate_token_name(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedBuffer<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUndelegateTokenName")
            .original_result()
    }

    /// The current amount of EGLD being staked via Liquid Staking amongst all the whitelisted Staking Providers 
    pub fn cash_reserve(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCashReserve")
            .original_result()
    }

    /// The current amount of rewards in EGLD 
    pub fn rewards_reserve(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardsReserve")
            .original_result()
    }

    /// The current amount of EGLD that belongs to the protocol 
    pub fn protocol_reserve(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getProtocolReserves")
            .original_result()
    }

    /// The current total amount of EGLD being undelegated from all staking providers 
    pub fn total_undelegated(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalUndelegated")
            .original_result()
    }

    /// The current total amount of EGLD that can be unbonded or withdraw from all staking providers 
    pub fn total_withdrawable(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalWithdrawable")
            .original_result()
    }

    /// The next penalty identifier 
    pub fn next_penalty_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getNextPenaltyId")
            .original_result()
    }

    /// A linked list of Delegation smart contracts ordered by their delegation score 
    pub fn delegation_contracts_list(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDelegationContractsList")
            .original_result()
    }

    /// Allows users to delegate their EGLD to a given staking provider Delegation smart contract bypassing the Delegation 
    /// Algorithm 
    pub fn migration_whitelist<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMigrationWhitelist")
            .argument(&user)
            .original_result()
    }

    pub fn num_whitelisted_users<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        delegation_contract: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getNumWhitelistedUsers")
            .argument(&delegation_contract)
            .original_result()
    }

    /// A list of blacklisted Delegation smart contracts 
    pub fn blacklisted_delegation_contracts(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBlacklistedDelegationContracts")
            .original_result()
    }

    /// The metadata for each Delegation smart contract 
    pub fn delegation_contract_data<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        delegation_contract: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, DelegationContractData<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDelegationContractData")
            .argument(&delegation_contract)
            .original_result()
    }

    /// The undelegation mode 
    pub fn undelegation_mode(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, UndelegationMode> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUndelegationMode")
            .original_result()
    }

    /// The last epoch a successful undelegation occur when the undelegation mode is of `Algorithm` type 
    pub fn last_undelegate_epoch(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastUndelegateEpoch")
            .original_result()
    }

    /// The last epoch a successful contract data update occur 
    pub fn last_contract_data_update_epoch(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastContractDataUpdateEpoch")
            .original_result()
    }

    /// The last epoch rewards have been claimed for a given Staking Provider Delegation smart contract 
    pub fn last_rewards_claim_epoch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        delegation_contract: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastClaimRewardsEpoch")
            .argument(&delegation_contract)
            .original_result()
    }

    /// The period between undelegations and unbonds 
    pub fn unbond_period(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUnbondPeriod")
            .original_result()
    }

    /// The final fee charged to users, including staking providers service fee and liquid staking fee 
    pub fn total_fee(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalFee")
            .original_result()
    }


    /// The Delegation Sampling model parameters 
    pub fn delegation_sampling_model(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, SamplingModel<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDelegationSamplingModel")
            .original_result()
    }

    /// Stores the Delegation smart contract data manager address 
    pub fn data_manager(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDataManager")
            .original_result()
    }

    /// Stores the random oracle address, used only for testing purposes 
    pub fn random_oracle(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRandomOracle")
            .original_result()
    }

    /// Allows users to redeem sEGLD in exchange for EGLD. Instead of immediately sending the EGLD to the user, an 
    /// undelegate NFT is minted and sent to the user. This NFT can be redeemed for EGLD once the unbond period has 
    /// passed through the `unbond` endpoint. The paid sEGLD is burned. 
    ///  
    /// If not provided, the Delegation smart contract for the undelegation is selected based on the current 
    /// configuration of the delegation algorithm. On the other hand, the Delegation smart contract can be specified 
    /// only if the undelegation mode is set to `Free`. 
    ///  
    /// Notice that this endpoint does not automatically perform the undelegation. Instead, anyone can perform the 
    /// undelegation at any given point in time using the `unDelegatePendingAmount` public endpoint. 
    ///  
    /// # Arguments 
    ///  
    /// - `opt_delegation_contract`: The address of the Delegation smart contract to undelegate from 
    ///  
    /// # Notes 
    ///  
    /// - There is a minimum amount of 1 EGLD for undelegations, which corresponds to a minimum amount of sEGLD 
    ///   depending on the current exchange rate. 
    ///  
    pub fn undelegate<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        opt_delegation_contract: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("unDelegate")
            .argument(&opt_delegation_contract)
            .original_result()
    }

    /// Initiates the undelegation of the pending amount from the specified Delegation smart contract. This endpoint 
    /// performs an asynchronous call to the Delegation smart contract to undelegate the pending amount. It is capable 
    /// of handling multiple calls, and the execution order of their callbacks does not need to match the order of the 
    /// original calls. 
    ///  
    /// # Arguments 
    ///  
    /// - `delegation_contract`: The address of the Delegation smart contract to undelegate from. 
    ///  
    /// # Notes 
    ///  
    /// - This endpoint can be called by anyone. 
    /// - There is no need to provide an optional argument for the amount of EGLD to undelegate. The pending amount to 
    ///   undelegate should always be sufficient and prevent leaving dust at the Delegation smart contract. Both the 
    ///   `undelegate` and `penalty_from_undelegation` functions ensure the adequacy of the pending amount. 
    ///  
    pub fn undelegate_pending_amount<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        delegation_contract: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unDelegatePendingAmount")
            .argument(&delegation_contract)
            .original_result()
    }

    /// Allows users to redeem undelegate NFTs in exchange for EGLD once the unbond period has passed. To successfully 
    /// redeem the EGLD, it must already be in the liquid staking smart contract. Therefore, the public endpoint 
    /// `withdrawFrom` should have been called prior to using this function. If the redemption is successful, the NFT is 
    /// burned, and the corresponding EGLD amount is sent to the caller. 
    ///  
    pub fn withdraw(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .raw_call("withdraw")
            .original_result()
    }

    /// Initiates the withdrawal of the withdrawable amount from the specified Delegation smart contract. This endpoint 
    /// performs an asynchronous call to withdraw the amount that has been previously undelegated and has passed the 
    /// unbond period. It is capable of handling multiple calls, and the execution order of their callbacks does not 
    /// need to match the order of the original calls. 
    ///  
    /// # Arguments 
    ///  
    /// - `delegation_contract`: The address of the Delegation smart contract to withdraw from. 
    ///  
    /// # Notes 
    ///  
    /// - This endpoint can be called by anyone. 
    /// - It only needs to be called once per epoch. 
    ///  
    pub fn withdraw_from<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        delegation_contract: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdrawFrom")
            .argument(&delegation_contract)
            .original_result()
    }

    /// Initiates a penalty to a Delegation smart contract. Penalties reduce the staked amount of a Delegation smart 
    /// contract through two different mechanisms: 
    ///  
    /// 1. By undelegating an amount of EGLD from the Delegation smart contract. 
    /// 2. By reducing the pending amount of EGLD to be delegated to the Delegation smart contract. 
    ///  
    /// The first mechanism can only be triggered by the admin when detecting misbehavior from the Staking Agency 
    /// associated with the Delegation smart contract. This penalty must be unbonded from the Delegation smart contract 
    /// at a future time using the `unbondPenalty` public endpoint. 
    ///  
    /// The second mechanism can be triggered by the admin in cases of Staking Agency misbehavior or when there is a 
    /// pending amount to be delegated that cannot be deposited due to current cap and total value locked values. The 
    /// community may also initiate this penalty if specific conditions are met. Since this penalty affects the pending 
    /// amount to be delegated, the EGLD is already present and does not need to be withdrawn. Therefore, the penalty is 
    /// marked as `withdrawn`. 
    ///  
    /// Finally, all penalties need to be delegated to a new Delegation smart contract. This is achieved by calling the 
    /// `delegatePenalty` endpoint. If for some reason this is not done, user will eventually have the chance to 
    /// undelegate from penalties. 
    ///  
    /// # Arguments 
    ///  
    /// - `delegation_contract`: The address of the Delegation smart contract. 
    /// - `source`: The source or type of the penalty. 
    /// - `opt_egld_amount`: The amount of EGLD to penalize. If unspecified, it defaults to the total delegated or 
    ///   pending amount to be delegated. 
    ///  
    pub fn penalize<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<PenaltySource>,
        Arg2: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        delegation_contract: Arg0,
        source: Arg1,
        opt_egld_amount: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("penalize")
            .argument(&delegation_contract)
            .argument(&source)
            .argument(&opt_egld_amount)
            .original_result()
    }

    /// Marks a penalty as withdrawn once the unbond period has passed. In order to be successful, the EGLD must be 
    /// already in the liquid staking smart contract. For that reason, the public endpoint `withdrawFrom` should have 
    /// been already called before this point. 
    ///  
    /// # Arguments 
    ///  
    /// - `penalty_id` - the penalty identifier 
    ///  
    pub fn withdraw_penalty<
        Arg0: ProxyArg<u64>,
    >(
        self,
        penalty_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdrawPenalty")
            .argument(&penalty_id)
            .original_result()
    }

    /// Allows anyone to delegate a Penalty to a new Delegation smart contract based on the current configuration of the 
    /// delegation algorithm, avoiding the penalized Delegation smart contract. Similarly to `delegate`, it does not 
    /// perform the delegation automatically, but it can be done by anyone at any given point in time using the 
    /// `delegatePendingAmount` public endpoint. 
    ///  
    /// # Arguments 
    ///  
    /// - `penalty_id` - the penalty identifier 
    /// - `opt_egld_amount` - the amount of EGLD to delegate. If unspecified, it defaults to the penalty amount 
    ///  
    pub fn delegate_penalty<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        penalty_id: Arg0,
        opt_egld_amount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("delegatePenalty")
            .argument(&penalty_id)
            .argument(&opt_egld_amount)
            .original_result()
    }

    /// A public endpoint that allows users to withdraw from penalties when the undelegation mode is set to `Free`. 
    /// Since penalties must be already marked as `withdrawn`, which means that the EGLD is already available at this 
    /// smart contract, the EGLD is sent directly to the user and the penalty is updated or cleared. 
    ///  
    /// # Arguments 
    ///  
    /// - `penalty_id` - the penalty identifier 
    ///  
    pub fn withdraw_from_penalty<
        Arg0: ProxyArg<u64>,
    >(
        self,
        penalty_id: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("withdrawFromPenalty")
            .argument(&penalty_id)
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub enum UndelegationMode {
    None,
    Algorithm,
    Open,
}


#[type_abi]
#[derive(TopEncode, TopDecode)]
pub enum DelegationScoreMethod {
    Tvl,
    Apr,
    Mixed,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct SamplingModel<Api>
where
    Api: ManagedTypeApi,
{
    pub tolerance: BigUint<Api>,
    pub max_service_fee: BigUint<Api>,
    pub premium: BigUint<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct DelegationContractData<Api>
where
    Api: ManagedTypeApi,
{
    pub contract: ManagedAddress<Api>,
    pub total_value_locked: BigUint<Api>,
    pub cap: Option<BigUint<Api>>,
    pub nr_nodes: u64,
    pub apr: BigUint<Api>,
    pub service_fee: BigUint<Api>,
    pub delegation_score: BigUint<Api>,
    pub pending_to_delegate: BigUint<Api>,
    pub total_delegated: BigUint<Api>,
    pub pending_to_undelegate: BigUint<Api>,
    pub total_undelegated: BigUint<Api>,
    pub total_withdrawable: BigUint<Api>,
    pub outdated: bool,
    pub blacklisted: bool,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct UndelegateAttributes<Api>
where
    Api: ManagedTypeApi,
{
    pub delegation_contract: ManagedAddress<Api>,
    pub egld_amount: BigUint<Api>,
    pub shares: BigUint<Api>,
    pub undelegate_epoch: u64,
    pub unbond_epoch: u64,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub enum State {
    Inactive,
    Active,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub enum PenaltySource {
    FromUndelegate,
    FromPendingToDelegate,
}
