// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct MoneyMarketProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for MoneyMarketProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = MoneyMarketProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        MoneyMarketProxyMethods { wrapped_tx: tx }
    }
}

pub struct MoneyMarketProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> MoneyMarketProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initialize the Money Market. 
    ///  
    /// # Arguments: 
    ///  
    /// - `underlying_id` - The underlying token identifier. 
    /// - `controller` - The address of the Controller. 
    /// - `interest_rate_model` - The address of the Interest Rate Model. 
    /// - `initial_exchange_rate` - The initial exchange rate in wad. 
    /// - `opt_admin` - An optional admin address for the contract. 
    ///  
    /// Notes: 
    ///  
    /// - If the contract is being deployed for the first time, the admin address will be set. 
    /// - If the admin address is not provided, the admin will be set as the deployer. 
    /// - If the contract is being upgraded, the admin address will not be overwritten. 
    /// - Upgrades won't change the underlying token identifier, initial exchange rate, accrual timestamp or the admin. 
    ///  
    pub fn init<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        underlying_id: Arg0,
        controller: Arg1,
        interest_rate_model: Arg2,
        initial_exchange_rate: Arg3,
        opt_admin: Arg4,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&underlying_id)
            .argument(&controller)
            .argument(&interest_rate_model)
            .argument(&initial_exchange_rate)
            .argument(&opt_admin)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> MoneyMarketProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> MoneyMarketProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Issue the ESDT Hatom Token. 
    ///  
    /// # Arguments: 
    ///  
    /// - `name` - The token display name for the Hatom token. 
    /// - `ticker` - The token ticker for the Hatom token. 
    /// - `decimals` - The decimal precision for the Hatom token. 
    ///  
    pub fn issue_esdt_token<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<usize>,
    >(
        self,
        name: Arg0,
        ticker: Arg1,
        decimals: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("issueEsdtToken")
            .argument(&name)
            .argument(&ticker)
            .argument(&decimals)
            .original_result()
    }

    /// Sets minting and burning roles for the Money Market smart contract with respect to the Hatom Token. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_market_roles(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMarketRoles")
            .original_result()
    }

    /// Sets minting and burning roles for the Controller smart contract with respect to the Hatom Token. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_controller_roles(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setControllerRoles")
            .original_result()
    }

    /// Mint at least the initial supply of Hatom tokens. These tokens will be burned to make sure that the total supply 
    /// never returns to zero. This is particularly useful because it enforces that the exchange rate will never returns to 
    /// its initial condition. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - Can only be called once. 
    /// - The initial supply is equal to the minimum initial supply. 
    /// - The remainder tokens are sent back to the caller. 
    ///  
    pub fn mint_initial_supply(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("mintInitialSupply")
            .original_result()
    }

    /// Returns the current admin address. 
    ///  
    pub fn get_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmin")
            .original_result()
    }

    /// Returns the current pending admin address, if there is one. 
    ///  
    pub fn get_pending_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingAdmin")
            .original_result()
    }

    /// Sets the pending admin address to the given address. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_pending_admin` - The new pending admin address. 
    ///  
    pub fn set_pending_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pending_admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingAdmin")
            .argument(&pending_admin)
            .original_result()
    }

    /// Attempts to accept the pending admin, which must be set first using the `set_pending_admin` endpoint. 
    pub fn accept_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptAdmin")
            .original_result()
    }

    /// A borrower requests underlying from the money market. 
    ///  
    /// # Arguments: 
    ///  
    /// - `underlying_amount` - The amount of underlying asset the borrower requests. 
    ///  
    pub fn borrow<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        underlying_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EgldOrEsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("borrow")
            .argument(&underlying_amount)
            .original_result()
    }

    /// A utility function to highlight that this smart contract is a Money Market. 
    ///  
    pub fn is_money_market(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isMoneyMarket")
            .original_result()
    }

    /// Checks whether the Hatom token has been already issued. 
    ///  
    pub fn is_token_issued(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isTokenIssued")
            .original_result()
    }

    /// This method is one of the most important methods of the protocol, as it accrues the borrows interest and distributes 
    /// that amount into reserves (including revenue and staking rewards). In order to do that, it solves the money market 
    /// dynamics using an Euler scheme. 
    ///  
    pub fn accrue_interest(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("accrueInterest")
            .original_result()
    }

    /// Accrues interest if a sufficient amount of time has elapsed since the last accrual. 
    ///  
    pub fn try_accrue_interest(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("tryAccrueInterest")
            .original_result()
    }

    /// Adds an specified amount of underlying coming as a payment to the money market reserves. 
    ///  
    /// Notes: 
    ///  
    /// - The underlying amount is added as protocol revenue. 
    /// - Must be paid with underlying. 
    /// - Does not change the exchange rate. 
    ///  
    pub fn add_reserves(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("addReserves")
            .original_result()
    }

    /// Translates an underlying amount to tokens. 
    ///  
    /// # Arguments: 
    ///  
    /// - `underlying_amount` - the amount of underlying to be converted to tokens. 
    ///  
    pub fn underlying_amount_to_tokens<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        underlying_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("underlyingAmountToTokens")
            .argument(&underlying_amount)
            .original_result()
    }

    /// Translates tokens to an underlying amount. 
    ///  
    /// # Arguments: 
    ///  
    /// - `tokens` - the amount of tokens to be converted to underlying. 
    ///  
    pub fn tokens_to_underlying_amount<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        tokens: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("tokensToUnderlyingAmount")
            .argument(&tokens)
            .original_result()
    }

    /// Translates an underlying amount to tokens using an updated exchange rate. 
    ///  
    /// # Arguments: 
    ///  
    /// - `underlying_amount` - the amount of underlying to be converted to tokens. 
    ///  
    pub fn current_underlying_amount_to_tokens<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        underlying_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("currentUnderlyingAmountToTokens")
            .argument(&underlying_amount)
            .original_result()
    }

    /// Translates tokens to an underlying amount using an updated exchange rate. 
    ///  
    /// # Arguments: 
    ///  
    /// - `tokens` - the amount of tokens to be converted to underlying. 
    ///  
    pub fn current_tokens_to_underlying_amount<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        tokens: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("currentTokensToUnderlyingAmount")
            .argument(&tokens)
            .original_result()
    }

    /// Returns the money market identifiers, i.e. the underlying identifier and the token identifier as a tuple. 
    ///  
    pub fn get_money_market_identifiers(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (EgldOrEsdtTokenIdentifier<Env::Api>, TokenIdentifier<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMoneyMarketIdentifiers")
            .original_result()
    }

    /// Returns the available cash. 
    ///  
    pub fn get_cash(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCash")
            .original_result()
    }

    /// Returns the updated amount of borrows. 
    ///  
    pub fn current_total_borrows(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentTotalBorrows")
            .original_result()
    }

    /// Returns the amount of borrows up to the last interaction that accrued interest. 
    ///  
    pub fn get_total_borrows(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalBorrows")
            .original_result()
    }

    /// Returns the discounted total borrows to the money market inception. This can be used as a base to calculate amounts 
    /// that depend on the borrows amounts, such as user rewards or discounts. Notice that it does not accrue interest. 
    ///  
    pub fn get_base_total_borrows(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBaseTotalBorrows")
            .original_result()
    }

    /// Returns the updated amount of reserves. 
    ///  
    pub fn current_total_reserves(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentTotalReserves")
            .original_result()
    }

    /// Returns the amount of protocol reserves up to the last interaction that accrued interest. 
    ///  
    pub fn get_total_reserves(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalReserves")
            .original_result()
    }

    /// Returns the updated amount of staking rewards. 
    ///  
    pub fn get_current_staking_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentStakingRewards")
            .original_result()
    }

    /// Returns the amount of staking rewards up to the last interaction that accrued interest. 
    ///  
    pub fn get_staking_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakingRewards")
            .original_result()
    }

    /// Returns the updated amount of historical staking rewards. 
    ///  
    pub fn get_current_historical_staking_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentHistoricalStakingRewards")
            .original_result()
    }

    /// Returns the amount of historical staking rewards up to the last interaction that accrued interest. 
    ///  
    pub fn get_historical_staking_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getHistoricalStakingRewards")
            .original_result()
    }

    /// Returns the updated amount of revenue. 
    ///  
    pub fn get_current_revenue(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentRevenue")
            .original_result()
    }

    /// Returns the amount of protocol revenue up to the last interaction that accrued interest. 
    ///  
    pub fn get_revenue(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRevenue")
            .original_result()
    }

    /// Returns the updated amount of liquidity. The liquidity is the cash plus the borrows minus the reserves. 
    ///  
    pub fn get_current_liquidity(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentLiquidity")
            .original_result()
    }

    /// Returns the amount of liquidity up to the last interaction that accrued interest. 
    ///  
    pub fn get_liquidity(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidity")
            .original_result()
    }

    /// Returns the reserve factor, i.e. the percentage of interest that is redirected to the reserves. 
    ///  
    pub fn get_reserve_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getReserveFactor")
            .original_result()
    }

    /// Returns the stake factor, i.e. the percentage of reserves that is redirected to the staking contract. 
    ///  
    pub fn get_stake_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakeFactor")
            .original_result()
    }

    /// Returns the address of the Interest Rate Model smart contract if set. 
    ///  
    pub fn get_interest_rate_model(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getInterestRateModel")
            .original_result()
    }

    /// Returns the address of the Controller smart contract if set. 
    ///  
    pub fn get_controller(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getController")
            .original_result()
    }

    /// Returns the address of the Staking smart contract if set. 
    ///  
    pub fn get_staking_contract(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakingContract")
            .original_result()
    }

    /// Returns the updated borrow amount of the given account. 
    ///  
    pub fn current_account_borrow_amount<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentAccountBorrowAmount")
            .argument(&account)
            .original_result()
    }

    /// Returns the borrow amount of the given account up to the last interaction that accrued interest or up to the current 
    /// time if a sufficient amount of time has elapsed since the last accrual. 
    ///  
    pub fn reliable_account_borrow_amount<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getReliableAccountBorrowAmount")
            .argument(&account)
            .original_result()
    }

    /// Returns the borrow amount of the given account up to the last interaction that accrued interest. 
    ///  
    pub fn stored_account_borrow_amount<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStoredAccountBorrowAmount")
            .argument(&account)
            .original_result()
    }

    /// Returns the discounted account borrows to the money market inception. This can be used to calculate amounts that 
    /// depend on the borrows amounts, such as user rewards or discounts. Notice that it does not accrue interest. 
    ///  
    pub fn base_account_borrow_amount<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBaseAccountBorrowAmount")
            .argument(&account)
            .original_result()
    }

    /// Returns the money market exchange rate and the borrow amount of the given account up to the last interaction that 
    /// accrued interest, in one shot. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account address to check. 
    ///  
    pub fn get_account_snapshot<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountSnapshot")
            .argument(&account)
            .original_result()
    }

    /// Returns the money market exchange rate and the borrow amount of the given account up to the last interaction that 
    /// accrued interest or up to the current time if a sufficient amount of time has elapsed since the last accrual, in one 
    /// shot. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account address to check. 
    ///  
    pub fn get_reliable_account_snapshot<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getReliableAccountSnapshot")
            .argument(&account)
            .original_result()
    }

    /// Returns the borrow index of the money market up to the last interaction that accrued interest or its initial 
    /// condition. Notice that the borrow index is a mechanism that allows updating all account borrows without having to 
    /// loop into each account when there is an interaction with the protocol that accrues interests. 
    ///  
    pub fn get_borrow_index(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowIndex")
            .original_result()
    }

    /// Returns the money market initial exchange rate. 
    ///  
    /// # Notes: 
    ///  
    /// - There is no need for a default value as it was initialized at money market construction. 
    ///  
    pub fn get_initial_exchange_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getInitialExchangeRate")
            .original_result()
    }

    /// Returns the current total supply of Hatom tokens, i.e. the amount of H-Tokens in circulation. 
    ///  
    pub fn get_total_supply(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalSupply")
            .original_result()
    }

    /// Initialized at money market construction, no need for default. 
    /// Returns the timestamp for the last interaction that accrued interest. 
    ///  
    pub fn get_accrual_timestamp(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccrualTimestamp")
            .original_result()
    }

    /// Returns the current money market exchange rate between underlying and tokens. 
    ///  
    pub fn get_current_exchange_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentExchangeRate")
            .original_result()
    }

    /// Returns the money market exchange rate between underlying and tokens up to the last interaction that accrued 
    /// interest. 
    ///  
    pub fn get_stored_exchange_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStoredExchangeRate")
            .original_result()
    }

    /// Returns the borrow rate per second up to the last interaction that accrued interest. 
    ///  
    pub fn borrow_rate_per_second(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowRatePerSecond")
            .original_result()
    }

    /// Returns the supply rate per second up to the last interaction that accrued interest. 
    ///  
    pub fn supply_rate_per_second(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSupplyRatePerSecond")
            .original_result()
    }

    /// Returns the borrow rate and the supply rate per second up to the last interaction that accrued interest. 
    ///  
    pub fn get_rates_per_second(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRatesPerSecond")
            .original_result()
    }

    /// Returns the close factor, used to determine the maximum amount of a borrow that can be repaid during a liquidation. 
    ///  
    pub fn get_close_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCloseFactor")
            .original_result()
    }

    /// Returns the current liquidation incentive. If liquidation incentive has not been configured yet, it returns one. This 
    /// assumption is correct given that the protocol seize share is zero by default. However, notice that the liquidation 
    /// incentive is configured at protocol deployment. 
    ///  
    pub fn get_liquidation_incentive(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidationIncentive")
            .original_result()
    }

    /// Returns the current protocol seize share. If it has has not been configured yet, it returns zero. This assumption is 
    /// correct given that the liquidation incentive is zero by default. However, notice that the protocol seize share is 
    /// configured at protocol deployment. 
    ///  
    pub fn get_protocol_seize_share(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getProtocolSeizeShare")
            .original_result()
    }

    /// Returns the accrual time threshold, used to determine when the accrued interest is too old. 
    ///  
    pub fn get_accrual_time_threshold(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccrualTimeThreshold")
            .original_result()
    }

    /// Sets the staking smart contract address. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_staking` - The Staking smart contract address. 
    ///  
    pub fn set_staking_contract<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        new_staking: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setStakingContract")
            .argument(&new_staking)
            .original_result()
    }

    /// Sets a new reserve factor. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_reserve_factor` - The new reserve factor in wad. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The new reserve factor must not exceed the maximum allowed. 
    ///  
    pub fn set_reserve_factor<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        new_reserve_factor: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setReserveFactor")
            .argument(&new_reserve_factor)
            .original_result()
    }

    /// Sets a new stake factor, i.e. the portion of the reserves that is used as staking rewards. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_stake_factor` - The new reserve factor in wad. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The new stake factor must not exceed the maximum allowed. 
    ///  
    pub fn set_stake_factor<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        new_stake_factor: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setStakeFactor")
            .argument(&new_stake_factor)
            .original_result()
    }

    /// Sets a new close factor used at liquidations. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_close_factor` - The new close factor in wad. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_close_factor<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        new_close_factor: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCloseFactor")
            .argument(&new_close_factor)
            .original_result()
    }

    /// Sets a new liquidation incentive for liquidations. 
    ///  
    /// # Arguments 
    ///  
    /// - `new_liquidation_incentive` - the new liquidation incentive in wad 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - the new liquidation incentive should not be less than the amount that would yield losses for liquidators 
    /// - the new liquidation incentive should be less than `1 / eff_ltv`, which is conservatively assumed to be `1 / 
    ///   max_ltv`. Otherwise, there won't be a Risky region. 
    ///  
    pub fn set_liquidation_incentive<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        new_liquidation_incentive: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLiquidationIncentive")
            .argument(&new_liquidation_incentive)
            .original_result()
    }

    /// Sets a new protocol seize share, i.e. the portion of the seized amount that is kept by the protocol. 
    ///  
    /// # Arguments 
    ///  
    /// - `new_protocol_seize_share` - the new protocol seize share in wad 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - the new protocol seize share cannot exceed the amount that would yield losses for liquidators 
    ///  
    pub fn set_protocol_seize_share<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        new_protocol_seize_share: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setProtocolSeizeShare")
            .argument(&new_protocol_seize_share)
            .original_result()
    }

    /// Sets a new Interest Rate Model. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_interest_rate_model` - The address of the new Interest Rate Model smart contract. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The provided address must be a valid Interest Rate Model smart contract. 
    ///  
    pub fn set_interest_rate_model<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        new_interest_rate_model: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setInterestRateModel")
            .argument(&new_interest_rate_model)
            .original_result()
    }

    /// Withdraws an specified amount of underlying from the money market reserves (revenue part) to the admin account. 
    ///  
    /// # Arguments: 
    ///  
    /// - `underlying_amount` - The amount of underlying to withdraw. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The underlying amount is directed to the admin account. 
    ///  
    pub fn reduce_reserves<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        underlying_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("reduceReserves")
            .argument(&underlying_amount)
            .original_result()
    }

    /// Sets a new accrual time threshold. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_accrual_time_threshold` - The new accrual time threshold in seconds. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_accrual_time_threshold<
        Arg0: ProxyArg<u64>,
    >(
        self,
        new_accrual_time_threshold: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setAccrualTimeThreshold")
            .argument(&new_accrual_time_threshold)
            .original_result()
    }

    /// Whitelists a trusted minter contract, i.e. a contract that can mint and enter market in the name of someone else. 
    ///  
    /// # Arguments: 
    ///  
    /// - `trusted_minter` - the new trusted minter to whitelist 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - `trusted_minter` must be a trusted smart contract 
    /// - `trusted_minter` must not be already trusted 
    ///  
    pub fn add_trusted_minter<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        trusted_minter: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addTrustedMinter")
            .argument(&trusted_minter)
            .original_result()
    }

    /// Removes a trusted minter contract address from the whitelist of trusted minters contracts. 
    ///  
    /// # Arguments: 
    ///  
    /// - `trusted_minter` - the trusted minter to remove 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - `trusted_minter` must has been already trusted 
    ///  
    pub fn remove_trusted_minter<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        trusted_minter: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeTrustedMinter")
            .argument(&trusted_minter)
            .original_result()
    }

    /// Liquidate a risky borrower by taking her Hatom's tokens deposited as collateral at a specified money market 
    ///  
    /// # Arguments: 
    ///  
    /// - `borrower` - The account to be liquidated. 
    /// - `collateral_mma ` - The money market in which to seize collateral from the borrower. 
    /// - `opt_min_tokens` - The minimum amount of tokens to be seized from the borrower. 
    ///  
    pub fn liquidate_borrow<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        borrower: Arg0,
        collateral_mma: Arg1,
        opt_min_tokens: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, MultiValue2<EsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .raw_call("liquidateBorrow")
            .argument(&borrower)
            .argument(&collateral_mma)
            .argument(&opt_min_tokens)
            .original_result()
    }

    /// Supply underlying to the money market, providing liquidity and accruing interest in exchange. In exchange, minted 
    /// Hatom tokens are directed to the caller, which can be redeemed for underlying at a given point in the future. 
    ///  
    pub fn mint(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("mint")
            .original_result()
    }

    /// Mints Hatom's tokens and enters the market in a single transaction. 
    ///  
    /// # Arguments: 
    ///  
    /// - `opt_account` - If given, the collateral will be deposited on the name of this account. Can only be performed by a 
    ///   trusted minter. 
    ///  
    /// # Notes: 
    ///  
    /// - Must be paid with the underlying asset. 
    ///  
    pub fn mint_and_enter_market<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        opt_account: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("mintAndEnterMarket")
            .argument(&opt_account)
            .original_result()
    }

    /// Exchanges caller paid Hatom's tokens back for her underlying asset. 
    ///  
    /// # Arguments: 
    ///  
    /// - `underlying_amount` - An optional amount of how much underlying wants to receive back given a sufficient amount of 
    ///   Hatom tokens are paid. 
    ///  
    pub fn redeem<
        Arg0: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        underlying_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, MultiValue2<EgldOrEsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .raw_call("redeem")
            .argument(&underlying_amount)
            .original_result()
    }

    /// Repays an outstanding borrow to the money market. 
    ///  
    /// # Arguments: 
    ///  
    /// - `borrower` - An optional address to repay on behalf of this account. 
    ///  
    /// Notes: 
    ///  
    /// - The repayment amount can be higher than the outstanding borrow. In such case, the remainder is returned. 
    ///  
    pub fn repay_borrow<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        borrower: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, EgldOrEsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("repayBorrow")
            .argument(&borrower)
            .original_result()
    }

    /// Handler for `seize_internal` via smart contract to smart contract calls. 
    ///  
    /// # Arguments: 
    ///  
    /// - `liquidator` - The account retrieving the seized collateral. 
    /// - `borrower` - The account having collateral seized. 
    /// - `tokens_to_seize` - The tokens to seize. 
    ///  
    pub fn seize<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        liquidator: Arg0,
        borrower: Arg1,
        tokens_to_seize: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("seize")
            .argument(&liquidator)
            .argument(&borrower)
            .argument(&tokens_to_seize)
            .original_result()
    }

    /// Stores the money market state. 
    pub fn market_state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, State> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getState")
            .original_result()
    }

    /// Stores the underlying identifier. 
    pub fn underlying_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EgldOrEsdtTokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUnderlyingId")
            .original_result()
    }

    /// Stores the token identifier. 
    pub fn token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenId")
            .original_result()
    }

    /// Stores whether the token is being issued or not. 
    pub fn ongoing_issuance(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getOngoingIssuance")
            .original_result()
    }

    /// Stores whether the token initial supply has been minted or not. 
    pub fn minted_initial_supply(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMintedInitialSupply")
            .original_result()
    }

    /// Stores the borrow snapshot for a given borrower account. 
    pub fn account_borrow_snapshot<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        borrower: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, AccountSnapshot<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountBorrowSnapshot")
            .argument(&borrower)
            .original_result()
    }

    /// Claims staking rewards from the staking contract, and sends them to the caller's account. 
    ///  
    /// This function accrues interest then retrieves the amount of staking rewards and checks if there are any rewards to 
    /// claim. If there are rewards, it transfers them from the protocol's cash balance to the caller's account, updates the 
    /// reserve and staking rewards balance. 
    ///  
    pub fn claim_staking_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimStakingRewards")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, PartialEq)]
pub enum State {
    Empty,
    Active,
    Inactive,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone)]
pub struct AccountSnapshot<Api>
where
    Api: ManagedTypeApi,
{
    pub borrow_amount: BigUint<Api>,
    pub borrow_index: BigUint<Api>,
}
